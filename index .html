<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Grand Luxury Tree - Magnetic Photos</title>
<style>
body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Microsoft YaHei', 'Songti SC', serif; }
#canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; cursor: grab; }
#canvas-container:active { cursor: grabbing; }
#gesture-hint { position: absolute; bottom: 10px; width: 100%; text-align: center; color: rgba(212,175,55,0.7); font-size: 10px; pointer-events: none; text-shadow: 0 0 5px #000; z-index: 5; }
.hidden { display: none !important; }
</style>
<script type="importmap">
{ "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" } }
</script>
</head>
<body>
<div id="canvas-container"></div>
<div id="gesture-hint">散开模式：鼠标靠近照片自动吸附 · 单击大幅放大 · 滚轮缩放</div>

<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

const SHARE_MODE = true;
const PRELOAD_PHOTO_URLS = [
  "./photos/1746430187491.jpeg",
  "./photos/1746430195706.jpeg",
  "./photos/1746430198495.jpeg",
  "./photos/DOUYIN_LP_1746003886510.jpg",
];

let scene, camera, renderer, composer, mainGroup, particleSystem=[], photoMeshGroup=new THREE.Group(), clock=new THREE.Clock();
const CONFIG = { colors:{bg:0x000000}, camera:{baseZ:50,minZ:15,maxZ:120}};
const STATE={mode:'TREE',rotation:{x:0,y:0},cameraZ:CONFIG.camera.baseZ,focusTarget:null};
let raycaster=new THREE.Raycaster(),mouse=new THREE.Vector2(),mouseWorld=new THREE.Vector3(),closestPhoto=null;

init();

async function init(){
  initThree(); setupEnvironment(); setupLights(); createParticles(); setupPostProcessing(); setupMouseEvents(); animate();
  // 加载预置照片
  for(const url of PRELOAD_PHOTO_URLS){ await createPhotoTextureFromUrl(url,url); }
  setMode('TREE');
}

// === Three.js 初始化 ===
function initThree(){
  const c=document.getElementById('canvas-container');
  scene=new THREE.Scene(); scene.background=new THREE.Color(CONFIG.colors.bg);
  camera=new THREE.PerspectiveCamera(42,window.innerWidth/window.innerHeight,0.1,1000);
  camera.position.set(0,2,CONFIG.camera.baseZ);
  renderer=new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth,window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
  c.appendChild(renderer.domElement);
  mainGroup=new THREE.Group(); scene.add(mainGroup); mainGroup.add(photoMeshGroup);
}

// === 环境光 ===
function setupEnvironment(){
  const p=new THREE.PMREMGenerator(renderer);
  scene.environment=p.fromScene(new RoomEnvironment(),0.04).texture;
}
function setupLights(){
  scene.add(new THREE.AmbientLight(0xffffff,0.7));
  const dir=new THREE.DirectionalLight(0xffeebb,0.8); dir.position.set(0,0,50); scene.add(dir);
}
function setupPostProcessing(){
  const r=new RenderPass(scene,camera);
  const b=new UnrealBloomPass(new THREE.Vector2(window.innerWidth,window.innerHeight),1.2,0.4,0.8);
  composer=new EffectComposer(renderer); composer.addPass(r); composer.addPass(b);
}

// === 粒子（星尘背景）===
function createParticles(){
  const g=new THREE.TetrahedronGeometry(0.1,0);
  const m=new THREE.MeshBasicMaterial({color:0xffeebb,transparent:true,opacity:0.5});
  for(let i=0;i<1500;i++){
    const s=new THREE.Mesh(g,m);
    s.position.set((Math.random()-0.5)*80,(Math.random()-0.5)*80,(Math.random()-0.5)*80);
    scene.add(s);
    particleSystem.push({mesh:s,type:'DUST'});
  }
}

// === 加载照片 ===
async function createPhotoTextureFromUrl(url,id){
  const img=new Image(); img.crossOrigin="anonymous"; img.src=url;
  await img.decode();
  const tex=new THREE.Texture(img); tex.colorSpace=THREE.SRGBColorSpace; tex.needsUpdate=true;
  addPhotoToScene(tex,id,img);
}
function addPhotoToScene(tex,id,img){
  const aspect=img.width/img.height; let w=1.2,h=1.2;
  if(aspect>1)h=w/aspect; else w=h*aspect;
  const fg=new THREE.BoxGeometry(w+0.2,h+0.2,0.05);
  const fm=new THREE.MeshStandardMaterial({color:0xc5a059,metalness:0.6,roughness:0.5});
  const f=new THREE.Mesh(fg,fm);
  const pg=new THREE.PlaneGeometry(w,h);
  const pm=new THREE.MeshBasicMaterial({map:tex});
  const p=new THREE.Mesh(pg,pm); p.position.z=0.04;
  const g=new THREE.Group(); g.add(f); g.add(p);
  g.scale.set(0.8,0.8,0.8);
  g.position.set((Math.random()-0.5)*20,(Math.random()-0.5)*10,(Math.random()-0.5)*10);
  photoMeshGroup.add(g);
  particleSystem.push({mesh:g,type:'PHOTO',baseScale:0.8});
}

// === 模式 ===
function setMode(mode){ STATE.mode=mode; if(mode==='FOCUS')document.getElementById('gesture-hint').innerText="点击空白退出查看"; else document.getElementById('gesture-hint').innerText="散开模式：鼠标靠近照片自动吸附 · 单击大幅放大"; }

// === 鼠标交互 ===
function setupMouseEvents(){
  const c=document.getElementById('canvas-container');
  c.addEventListener('mousemove',(e)=>{
    mouse.x=(e.clientX/window.innerWidth)*2-1;
    mouse.y=-(e.clientY/window.innerHeight)*2+1;
    raycaster.setFromCamera(mouse,camera);
    const plane=new THREE.Plane(new THREE.Vector3(0,0,1),-camera.position.z);
    raycaster.ray.intersectPlane(plane,mouseWorld);
  });
  c.addEventListener('click',(e)=>{
    raycaster.setFromCamera(mouse,camera);
    const photos=particleSystem.filter(p=>p.type==='PHOTO').map(p=>p.mesh);
    const inter=raycaster.intersectObjects(photos,true);
    if(STATE.mode==='SCATTER' && inter.length>0){
      STATE.focusTarget=inter[0].object.parent; setMode('FOCUS');
    } else if(STATE.mode==='FOCUS' && inter.length===0){ setMode('SCATTER'); }
  });
  c.addEventListener('wheel',(e)=>{ e.preventDefault(); STATE.cameraZ+=e.deltaY*0.05; STATE.cameraZ=THREE.MathUtils.clamp(STATE.cameraZ,CONFIG.camera.minZ,CONFIG.camera.maxZ); camera.position.z=STATE.cameraZ; },{passive:false});
  c.addEventListener('dblclick',()=>{ setMode(STATE.mode==='TREE'?'SCATTER':'TREE'); });
}

// === 动画 ===
function animate(){
  requestAnimationFrame(animate);
  const dt=clock.getDelta();
  mainGroup.rotation.y+=0.1*dt;

  particleSystem.forEach(p=>{
    if(p.type==='PHOTO'){
      if(STATE.mode==='FOCUS' && STATE.focusTarget===p.mesh){
        p.mesh.position.lerp(new THREE.Vector3(0,0,0),3*dt);
        p.mesh.scale.lerp(new THREE.Vector3(3.5,3.5,3.5),3*dt);
      } else if(STATE.mode==='SCATTER'){
        p.mesh.scale.lerp(new THREE.Vector3(0.8,0.8,0.8),2*dt);
      } else if(STATE.mode==='TREE'){
        p.mesh.scale.lerp(new THREE.Vector3(0.8,0.8,0.8),2*dt);
      }
      p.mesh.lookAt(camera.position);
    }
  });
  composer.render();
}
</script>
</body>
</html>
